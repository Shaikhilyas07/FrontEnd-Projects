'use strict';

const Root = require('./root');
const Value = require('./value');

const AtWord = require('./atword');
const Colon = require('./colon');
const Comma = require('./comma');
const Comment = require('./comment');
const Func = require('./function');
const Numbr = require('./number');
const Operator = require('./operator');
const Paren = require('./paren');
const Str = require('./string');
const Word = require('./word');
const UnicodeRange = require('./unicode-range');

const tokenize = require('./tokenize');

const flatten = require('flatten');
const indexesOf = require('indexes-of');
const uniq = require('uniq');
const ParserError = require('./errors/ParserError');

function sortAscending (list) {
  return list.sort((a, b) => a - b);
}

module.exports = class Parser {
  constructor (input, options) {
    const defaults = { loose: false };

    // cache needs to be an array for values with more than 1 level of function nesting
    this.cache = [];
    this.input = input;
    this.options = Object.assign({}, defaults, options);
    this.position = 0;
    // we'll use this to keep track of the paren balance
    this.unbalanced = 0;
    this.root = new Root();

    let value = new Value();

    this.root.append(value);

    this.current = value;
    this.tokens = tokenize(input, this.options);
  }

  parse () {
    return this.loop();
  }

  colon () {
    let token = this.currToken;

    this.newNode(new Colon({
      value: token[1],
      source: {
        start: {
          line: token[2],
          column: token[3]
        },
        end: {
          line: token[4],
          column: token[5]
        }
      },
      sourceIndex: token[6]
    }));

    this.position ++;
  }

  comma () {
    let token = this.currToken;

    this.newNode(new Comma({
      value: token[1],
      source: {
        start: {
          line: token[2],
          column: token[3]
        },
        end: {
          line: token[4],
          column: token[5]
        }
      },
      sourceIndex: token[6]
    }));

    this.position ++;
  }

  comment () {
    let inline = false,
      value = this.currToken[1].replace(/\/\*|\*\//g, ''),
      node;

    if (this.options.loose && value.startsWith("//")) {
      value = value.substring(2);
      inline = true;
    }

    node = new Comment({
      value: value,
      inline: inline,
      source: {
        start: {
          line: this.currToken[2],
          column: this.currToken[3]
        },
        end: {
          line: this.currToken[4],
          column: this.currToken[5]
        }
      },
      sourceIndex: this.currToken[6]
    });

    this.newNode(node);
    this.position++;
  }

  error (message, token) {
    throw new ParserError(message + ` at line: ${token[2]}, column ${token[3]}`);
  }

  loop () {
    while (this.position < this.tokens.length) {
      this.parseTokens();
    }

    if (!this.current.last && this.spaces) {
      this.current.raws.before += this.spaces;
    }
    else if (this.spaces) {
      this.current.last.raws.after += this.spaces;
    }

    this.spaces = '';

    return this.root;
  }

  operator () {

    // if a +|- operator is followed by a non-word character (. is allowed) and
    // is preceded by a non-word character. (5+5)
    let char = this.currToken[1],
      node;

    if (char === '+' || char === '-') {
      // only inspect if the operator is not the first token, and we're only
      // within a calc() function: the only spec-valid place for math expressions
      if (!this.options.loose) {
        if (this.position > 0) {
          if (this.current.type === 'func' && this.current.value === 'calc') {
            // allow operators to be proceeded by spaces and opening parens
            if (this.prevToken[0] !== 'space' && this.